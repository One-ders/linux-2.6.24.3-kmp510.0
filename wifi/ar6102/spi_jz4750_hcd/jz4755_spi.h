
// spi_dev @ c0029684, running dump
//
// (16*0) +0 ( 0)  = ??         = 0         @ c0029684
// (16*0) +4 ( 4)  = ??         = 00200200  @ c0029688
// (16*0) +8 ( 8)  = ??         = ffff8dd3  @ c002968c
// (16*0) +c (12)  = TimerTimeout = c00239c0  @ c0029690
// (16*1) +0 (16)  = &spi_dev   = c0029684  @ c0029694
// (16*1) +4 (20)  = ??         = 8032fda0  @ c0029698
// (16*1) +8 (24)  = ??         = 0x100     @ c002969c
// (16*1) +c (28)  = ??         = 1         @ c00296a0
// (16*2) +0 (32)  = &hcdContext= c002940c  @ c00296a4
// (16*2) +4 (36)  = ??         = 8109e500  @ c00296a8
// (16*2) +8 (40)  = ??         = c00296ac  @ c00296ac
// (16*2) +c (44)  = ??         = c00296ac  @ c00296b0
// (16*3) +0 (48)  = hcd_ssicomplete_wqueue_handler = c00239e8  @ c00296b4
// (16*3) +4 (52)  = ??         = 0         @ c00296b8
// (16*3) +8 (56)  = ??         = c00296bc  @ c00296bc
// (16*3) +c (60)  = ??         = c00296bc  @ c00296c0
// (16*4) +0 (64)  = hcd_iocomplete_wqueue_handler = c00233ec  @ c00296c4
// (16*4) +4 (68)  = ??         = 8109e500  @ c00296c8
// (16*4) +8 (72)  = ??         = c00296cc  @ c00296cc
// (16*4) +c (76)  = ??         = c00296cc  @ c00296d0
// (16*5) +0 (80)  = hcd_procirq_wqueue_handler = c0023bf0  @ c00296d4
// (16*5) +4 (84)  = ??         = 0         @ c00296d8
// (16*5) +8 (88)  = ??         = c00296dc  @ c00296dc
// (16*5) +c (92)  = ??         = c00296dc  @ c00296e0
// (16*6) +0 (96)  = hcd_dmacomplete_wqueue_handler = c0023bd8  @ c00296e4
// (16*6) +4 (100) = ??         = 0         @ c00296e8
// (16*6) +8 (104) = ??         = 000001e8  @ c00296ec
// (16*6) +c (108) = ??         = 01e0a6e0  @ c00296f0
// (16*7) +0 (112) = ??         = 6         @ c00296f4
// (16*7) +4 (116) = ??         = 7         @ c00296f8
// (16*7) +8 (120) = ??         = 0x50      @ c00296fc
// (16*7) +c (124) = ??         = 0         @ c0029700
// (16*8) +0 (128) = ??         = 1         @ c0029704
// (16*8) +4 (132) = ??         = 1         @ c0029708
// (16*8) +8 (136) = ??         = 81887000  @ c002970c
// (16*8) +c (140) = ??         = 01887000  @ c0029710
// (16*9) +0 (144) = ??         = 81886000  @ c0029714
// (16*9) +4 (148) = ??         = 01886000  @ c0029718


// hcd_context @ c002940c, running dump
//
// (16*0)+0 ( 0)   = ??         = 0         @ c002940c
// (16*0)+4 ( 4)   = ??         = 0         @ c0029410
// (16*0)+8 ( 8)   = ??         = 0         @ c0029414
// (16*0)+c (12)   = ??         = 0         @ c0029418
// (16*1)+0 (16)   = ??         = 000e0000  @ c002941c
// (16*1)+4 (20)   = ??         = 0100029e  @ c0029420
// (16*1)+8 (24)   = ??         = 1         @ c0029424
// (16*1)+c (28)   = ??         = 0x776     @ c0029428
// (16*2)+0 (32)   = ??         = 0x7db     @ c002942c
// (16*2)+4 (36)   = ??         = 0         @ c0029430
// (16*2)+8 (40)   = ??         = 824b2066  @ c0029434
// (16*2)+c (44)   = ??         = 0x60      @ c0029438
// (16*3)+0 (48)   = ??         = 01000100  @ c002943c
// (16*3)+4 (52)   = ??         = 0x1000    @ c0029440
// (16*3)+8 (56)   = ??         = 1         @ c0029444
// (16*3)+c (60)   = ??         = 01e0a6e0  @ c0029448
// (16*4)+0 (64)   = dev_spi    = c0029684  @ c002944c
// (16*4)+4 (68)   = ??         = 0x27      @ c0029450
// (16*4)+8 (72)   = ??         = 8110c090  @ c0029454
// (16*4)+c (76)   = ??         = 8110c090  @ c0029458
// (16*5)+0 (80)   = ??         = c0026f74  @ c002945c
// (16*5)+4 (84)   = ??         = 0x1000    @ c0029460
// (16*5)+8 (88)   = ??         = 0x10800   @ c0029464
// (16*5)+c (92)   = ??         = 0         @ c0029468
// (16*6)+0 (96)   = ??         = 02dc6c00  @ c002946c
// (16*6)+4 (100)  = ar6k_spi   = c002940c  @ c0029470
// (16*6)+8 (104)  = HcdRequest = c0025e24  @ c0029474
// (16*6)+c (108)  = HcdConfig  = c0026444  @ c0029478
// (16*7)+0 (112)  = ??         = 1         @ c002947c
// (16*7)+4 (116)  = ??         = c0029480  @ c0029480
// (16*7)+8 (120)  = ??         = c0029480  @ c0029484
// (16*7)+c (124)  = ??         = c0029488  @ c0029488
// (16*8)+0 (128)  = ??         = c0029488  @ c002948c
// (16*8)+4 (132)  = ??         = 0         @ c0029490
// (16*8)+8 (136)  = ??         = 0         @ c0029494
// (16*8)+c (140)  = ??         = 00080000  @ c0029498
// (16*9)+0 (144)  = ??         = 02dc6c00  @ c002949c
// (16*9)+4 (148)  = ??         = 00010800  @ c00294a0
// (16*9)+8 (152)  = ??         = 0         @ c00294a4
// (16*9)+c (156)  = ??         = 80369548  @ c00294a8
// (16*10)+0 (160) = ??         = 0         @ c00294ac
// (16*10)+4 (164) = ??         = 0         @ c00294b0
// (16*10)+8 (168) = ??         = c00294b4  @ c00294b4
// (16*10)+c (172) = ??         = c00294b4  @ c00294b8
// (16*11)+0 (176) = ??         = 0         @ c00294bc
// (16*11)+4 (180) = ??         = c00294c0  @ c00294c0
// (16*11)+8 (184) = ??         = c00294c0  @ c00294c4
// (16*11)+c (188) = ??         = c0029450  @ c00294c8
// (16*12)+0 (192) = SDIOIrqHelperFunction = c001cfb0 @ c00294cc
// (16*12)+4 (196) = ??         = 81847000  @ c00294d0
// (16*12)+8 (200) = ??         = 20200     @ c00294d4
// (16*12)+c (204) = ??         = 2         @ c00294d8
// (16*13)+0 (208) = ??         = 0         @ c00294dc
// (16*13)+4 (212) = ??         = 0         @ c00294e0
// (16*13)+8 (216) = ??         = c00294e4  @ c00294e4
// (16*13)+c (220) = ??         = c00294e4  @ c00294e8
// (16*14)+0 (224) = ??         = 0         @ c00294ec
// (16*14)+4 (228) = ??         = 0         @ c00294f0
// (16*14)+8 (232) = __this_module = c0029520 @ c00294f4
// (16*14)+c (236) = ??         = 0         @ c00294f8
// (16*15)+0 (240) = ??         = 0         @ c00294fc
// (16*15)+4 (244) = ??         = 0         @ c0029500
// (16*15)+8 (248) = ??         = 2         @ c0029504
#if 0
struct hcd_context  { // size 252 bytes
	unsigned int pad0;	  // 0-3
	unsigned int pad4;	  // 4-7
	unsigned char ub8;	  // 8
	unsigned char ub9;	  // 9
	unsigned char ub10;	  // 10
	unsigned char ub11;	  // 11
        unsigned int pad12;       // 12-15
	unsigned short int uh16;  // 16-17
	unsigned short int uh18;  // 18-19
	unsigned int    uw20;	  // 20-23
	unsigned short int uh24;  // 24-25
	unsigned short int uh26;  // 26-27
	unsigned int pad28[3];	  // 28-39
	unsigned short int *w40;  // 40-43
	int w44;  	          // 44-47
	unsigned char ub48;	  // 48
	unsigned char ub49;	  // 49
	unsigned short pad50;	  // 50-51
        unsigned int pad52[2];    // 52-59
	unsigned int op_clock;    // 60-63
	struct spi_dev *pDev;     // 64-67
        SDHCD pHcd;               // 68-247
	char		b248;	  // 248
	unsigned char	ub249;	  // 249
	char		b250;	  // 250
	char		b251;	  // 251
};
#endif

typedef enum {
    ATH_SPI_AR6002 = 0,
    ATH_SPI_AR6003 = 1,
} ATH_SPI_CHIP_TYPE;

#define AR6003_WRITE_BUFFER_SIZE   3163


typedef struct _SDHCD_DEVICE {
    SDLIST        List;                   /* linked list */
    BOOL          ShuttingDown;           /* indicates shut down of HCD) */
    UINT32        PollWait;               /* poll timeout for an operation */
    UINT8         CurrentDMADataMode;     /* current data mode */
    UINT16        SpiIntEnableShadow;     /* shadow copy of interrupt enables */
    UINT16        SpiConfigShadow;        /* shadow copy of configuration register */
//    OS_CRITICALSECTION CritSection;
    BOOL          ExternalIOPending;      /* flag indicating that external host I/O access is pending */
    UINT8         HostAccessDataWidth;    /* data width to use for host access */
    UINT8         DMADataWidth;           /* data width to use for DMA access */
    BOOL          DMAWriteWaitingForBuffer; /* DMA operation is waiting for buffer space */
    BOOL          DMAHWTransferInProgress;  /* DMA hardware transfer is running */
    UINT32        WriteBufferSpace;         /* 28, cached copy of space remaining in the SPI
                                               write buffer */
    UINT32        MaxWriteBufferSpace;      /* 32, max write buffer space that the SPI interface supports */
    UINT32        PktsInSPIWriteBuffer;     /* 36, number of packets in SPI write buffer so far */
//    ATH_SPI_CHIP_TYPE ChipType;             /* chip type */
    /********************************************
     *  the following fields are filled in by the common layer and used by the HW layer
     * to process a DMA request
     *
     ********************************************/
    PUINT8        pCurrentBuffer;         /* current buffer position for DMA */
    UINT32        CurrentTransferLength;  /* current transfer length for common buffer DMA */
    BOOL          CurrentTransferDirRx;   /* current transfer is RX direction */
    UINT8         CurrentDmaWidth;        /* current DMA transfer width */
    BOOL          HostDMABufferCopyMode;  /* DMA transfer copy mode, passed to hardware layer for
                                             common buffer copies */
    BOOL          HostAccessCopyMode;     /* host access copy mode */
#define BYTE_SWAP    TRUE
#define NO_BYTE_SWAP FALSE

    /*******************************************
     *
     * the following fields must be filled in by the hardware specific layer
     *
     ********************************************/
    UINT32        MaxBytesPerDMARequest;  /* maximum number of bytes per DMA request */
    UINT32        PowerUpDelay;           /* delay before the common layer should initialize over spi */
    UINT32        OperationalClock;       /* spi module operational clock */
    PVOID         pHWDevice;              /* hardware device portion*/
    SDHCD         Hcd;                    /* HCD description for bus driver */
    UINT8         SpiHWCapabilitiesFlags; /* SPI hardware capabilities flags */
    #define       HW_SPI_FRAME_WIDTH_8    0x01
    #define       HW_SPI_FRAME_WIDTH_16   0x02
    #define       HW_SPI_FRAME_WIDTH_24   0x04
    #define       HW_SPI_FRAME_WIDTH_32   0x08
    #define       HW_SPI_INT_EDGE_DETECT  0x80
    #define       HW_SPI_NO_DMA           0x40
    UINT8         MiscFlags;
    #define       MISC_FLAG_SPI_SLEEP_WAR          0x04
    #define       MISC_FLAG_RESET_SPI_IF_SHUTDOWN  0x02
    #define       MISC_FLAG_DUMP_STATE_ON_SHUTDOWN 0x01
    BOOL          FatalError;
} SDHCD_DEVICE, *PSDHCD_DEVICE;

typedef void (*PSDHC_IRQ_SYNC_CALLBACK)(PSDHCD_DEVICE, UINT32 Param1, UINT32 Param2);


struct spi_dev { // size 152 bytes
	struct timer_list	spi_timer;   // 0-11
//	unsigned int pad1[3];     // 0-11
//	void (*ttimeout)(struct spi_dev *);  // 12-15
//	struct spi_dev *dev;		     // 16-19
//	unsigned int w20;		     // 20-23
	unsigned char ub24;		     // 24
	unsigned char ub25;		     // 25
	unsigned short int uh26;	     // 26-27
	unsigned int w28;		     // 28-31
	PSDHCD_DEVICE      pHcd_ctx;         // 32-35
	struct work_struct ssicomplete_work; // 36-51
	struct work_struct iocomplete_work;  // 52-67
	struct work_struct procirq_work;     // 68-83
	struct work_struct dmacomplete_work; // 84-99
	unsigned int w100;                   // 100-103
	unsigned char ub104;                  // 104
        unsigned char ub105;                  // 105
	unsigned short int pad5;             // 106-107
	unsigned int op_clock_current;       // 108-111
	int TxDmaChannel;		     // 112-115
	int RxDmaChannel;		     // 116-119
	unsigned int w120;		     // 120-123
	         int w124;		     // 124-127
	unsigned int w128;		     // 128-131
	unsigned int w132;		     // 132-135
	unsigned char *pDmaDescriptorBuffer; // 136-139
	unsigned int DmaDescriptorPhys;      // 140-143
	unsigned char *pDmaCommonBuffer;     // 144-147
	unsigned int DmaCommonBufferPhys;    // 148-151
};



void HW_StartTimer(PSDHCD_DEVICE pDevice, int ms, int Context);
void HW_StopTimer(PSDHCD_DEVICE hcd_ctx);
void HW_UsecDelay(void *a0, unsigned int usec);
void HW_StartDMA(PSDHCD_DEVICE hcd_ctx);
void HcdDmaCompletion(PSDHCD_DEVICE hcd_ctx, SDIO_STATUS status);
SDIO_STATUS HW_QueueDeferredCompletion(PSDHCD_DEVICE pDevice);
SDIO_STATUS HW_SpiSetUpDMA(PSDHCD_DEVICE h_ctx);
SDIO_STATUS HW_InOut_Token(PSDHCD_DEVICE hcd_ctx,
                unsigned int out_token,
                unsigned char datasize,
                unsigned int *in_token);
//                BOOL stat_check);


extern int debuglevel;

